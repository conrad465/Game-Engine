USE_CASES.md
============
#### Game Authoring Enviroment Use Cases:
1. Drag and place a sprite into the game authoring environment.
2. Define whether a sprite remains in place or is movable. 
3. Define how a sprite will move around during the game.
4. Create a starting and ending point (goal) for a specific level.
5. Add a new (blank) level to the game authoring environment.
6. Upload a new image for a sprite from the file system.
7. Define how fast a sprite will move throughout the game.
8. Switch between the current levels using a tab navigator. 
9. Define the background of a game level.
10. Load a game project to work on.
11. Saving a game to a file to be opened with the player/engine

#### Player Use Cases:
1. Escape Key is pressed to bring up pause menu
2. Save current state of the game in a file that can be loaded in the future
3. Pause Menu with multiple buttons that can configure the game settings such as difficulty, sound, appearance etc.
4. Creating an instance of the game player in the authoring environment
5. Start game button is pressed to initialize and render the game
6. Open a save file
7. Update HUD while playing the game
8. Transition to next level
9. High scores on start screen
10. Restart the game/level

#### Engine Use Cases:
1. The right key is pressed, and the player character moves to the right.
2. The player character jumps, and falls due to gravity.
3. The player character is injured by an enemy.
4. The player character kills an enemy.
5. The authoring environment creates a new block and sets that block to be a fire block.
6. The authoring environment gives the player a low gravity setting.
7. The player picks up a power-up, and the power up changes how the player is viewed on the screen.
8.  An object off screen is decided to be placed on the screen after the player moves towards it.
9.  An object on screen is moved off the screen when the player moves away from it.
10. The player attempts to jump when it is already in midair. 
11. The player is falling down and lands on a block. 
12. An invincible flying fire-shooting enemy that explodes on contact is added to the game.
13. The player gains extra health and is damaged in the same game cycle.
14. A level is completed by the player reaching an end point. 
15. The player is hit by a fire ball.
16. The player hits the super power block.
17. The player steps on the enemy (koopa).
18. The player touches the flag and level is completed.

#### Data Use cases
1. The author wants to load a saved game in progress to continue working - authoring environment will have a class that reads in the data as a in progress game and that class will manage the parsing and create game objects based on properties files and set the values and criteria to the intended states given by the data file.
2. The author wants to save the in progress game. The authoring environment will send a game state object which contains all objects in the game. this class will be used to call each of its contained objects to send information to the file writer which will write these values to a file
3. The player wants to save their progress while in game. This will occur at checkpoints that will be specified by the authoring environmet. a game state will be generated by the player by querying engine for the states of all objects in the world and that will be sent  to a data writing class that will save it as a in play game. 
4. The author wants to create multiple levels within a game. A file management class wil be called to handle mulitple related files and a packaging method/class will organize these. Additionally, a default heirarchy will defined by the author 
5. The player wants to play a multiplayer game. The data from a game will have to be highly condensed to active components byu a network data class then sent and deciphered. There will also require a listner class to watch a network and bring in chnages and apply them to the game as well 